---
title: Thinking in Java 学习笔记
date: 2017-03-16
tags: Java
---


# 多线程
- “多任务”操作系统能同时运行多个进程(程序)——但实际是由于 CPU 分时机制的作用,使每个进程都能循环获得自己的 CPU 时间片。但由于轮换速度非常快,使得所有程序好象是在“同时”运行一样。“线程”
是进程内部单一的一个顺序控制流。因此,一个进程可能容纳了多个同时执行的线程。

- 事实上,多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。

- 线程机制多少降低了一些计算效率,但无论程序的设计,资源的均衡,还是用户操作的方便性,都从中获得了巨大的利益。当然,如果本来就安装了多块 CPU,那么操作系统能够自行决定为不同的 CPU 分配哪些线程,程序的总体运行速度也会变得更快(所有这些都要求操作系统以及应用程序的支持)。多线程和多任务是充分发挥多处理机系统能力的一种最有效的方式。

- CPU 处理一个现有线程集的顺序是不确定的——除非我们亲自介入,并用 Thread 的 setPriority()方法调整它们的优先级。
- 普通对象对于垃圾收集来说是一种“公平竞赛”,但线程却并非如此。每个线程都会“注册”自己,所以某处实际存在着对它的一个引用。这样一来,
垃圾收集器便只好对它“瞠目以对”了。

> 个人理解：普通的对象比线程更容易被回收，原因是线程的引用会被存起来。

- 若某样东西有一个 Runnable 接口,实际只是意味着它有一个 run()方法,但不存在与之相关的任何特殊东
西——它不具有任何天生的线程处理能力,这与那些从 Thread 继承的类是不同的。

--------------

### Java 如何共享资源
- 对一种特殊的资源——对象中的内存——Java 提供了内建的机制来防止它们的冲突。由于我们通常将数据元
素设为从属于 private(私有)类,然后只通过方法访问那些内存,所以只需将一个特定的方法设为
synchronized(同步的),便可有效地防止冲突。***在任何时刻,只可有一个线程调用特定对象的一个
synchronized 方法*** (尽管那个线程可以调用多个对象的同步方法)

- 如果只同步其中的一个方法,那么另一个就可以自
由忽视对象的锁定,并可无碍地调用。所以必须记住一个重要的规则:对于 ***访问某个关键共享资源的所有方
法,都必须把它们设为 synchronized*** ,否则就不能正常地工作。

- 要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。

> 在能进入同步块之前,必须在 synchObject 上取得锁。如果已有其他线程取得了这把锁,块便不能进入,必
须等候那把锁被释放

--------------

### synchronized 同步的效率
- 由于要为同样的数据编写两个方法,所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做
法是将所有方法都设为自动同步,并完全消除 synchronized 关键字(当然,含有 synchronized run()的例
子显示出这样做是很不通的)。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的
代价(进入和退出方法,不执行方法主体)至少要累加到四倍,而且根据我们的具体现方案,这一代价还有
可能变得更高。所以假如已知一个方法不会造成冲突,最明智的做法便是撤消其中的 synchronized 关键字。
--------------
### 线程的四个状态
1. 新(New):线程对象已经创建,但尚未启动,所以不可运行。
2. 可运行(Runnable ):意味着一旦时间分片机制有空闲的 CPU 周期提供给一个线程,那个线程便可立即
开始运行。因此,线程可能在、也可能不在运行当中,但一旦条件许可,没有什么能阻止它的运行——它既
没有“死”掉,也未被“堵塞”。
3. 死(Dead):从自己的 run()方法中返回后,一个线程便已“死”掉。亦可调用 stop()令其死掉,但会
产生一个违例——属于 Error 的一个子类(也就是说,我们通常不捕获它)。记住一个违例的“掷”出应当
是一个特殊事件,而不是正常程序运行的一部分。所以不建议你使用 stop()(在 Java 1.2 则是坚决反
对)。另外还有一个 destroy()方法(它永远不会实现),应该尽可能地避免调用它,因为它非常武断,根
本不会解除对象的锁定。
4. 堵塞(Blocked):线程可以运行,但有某种东西阻碍了它。若线程处于堵塞状态,调度机制可以简单地
跳过它,不给它分配任何 CPU 时间。除非线程再次进入“可运行”状态,否则不会采取任何操作。

--------------

### 为什么会堵塞?
线程被堵塞可能是由下述五方面的原因造成的:
1. 调用 `sleep`(毫秒数),使线程进入“睡眠”状态。在规定的时间内,这个线程是不会运行的。
2. 用 `suspend()` 暂停了线程的执行。除非线程收到 `resume()` 消息,否则不会返回“可运行”状态。
3. 用 `wait()` 暂停了线程的执行。除非线程收到 `nofify()` 或者 `notifyAll()` 消息,否则不会变成“可运行”(是的,这看起来同原因 `2` 非常相象,但有一个明显的区别是我们马上要揭示的)。
4. 线程正在等候一些 `IO`(输入输出)操作完成。
5. 线程试图调用另一个对象的 `同步` 方法,但那个对象处于锁定状态,暂时无法使用。

> 亦可调用 `yield()`(Thread 类的一个方法)`自动放弃 CPU`,以便其他线程能够运行。然而,假如调度机制觉
得我们的线程已拥有足够的时间,并跳转到另一个线程,就会发生同样的事情。也就是说,没有什么能防止
调度机制重新启动我们的线程。线程被堵塞后,便有一些原因造成它不能继续运行。

---------

### 等待和通知
***无论 sleep()还是 suspend()都不会在自己被调用的时候解除锁定。*** 需要用到对象锁时,请务必注意这个问题。在另一方面,***wait()方法在被调用时却会解除锁定***,这意味着可在执行
wait()期间调用线程对象中的其他同步方法。但在接着的两个类中,我们看到 run()方法都是“同步”的。
在 wait()期间,Peeker 仍然拥有对同步方法的完全访问权限。这是由于 wait()在挂起内部调用的方法时,
会解除对象的锁定。
我们也可以看到 wait()的两种形式。第一种形式采用一个以毫秒为单位的参数,它具有与 sleep()中相同的
含义:暂停这一段规定时间。区别在于在 wait()中,对象锁已被解除,而且能够自由地退出 wait(),因为一
个 notify() 可强行使时间流逝。
第二种形式不采用任何参数,这意味着 wait()会持续执行,直到 notify()介入为止。而且在一段时间以后,
不会自行中止。
wait()和 notify()比较特别的一个地方是这两个方法都属于基础类 Object 的一部分,不象 sleep(),
suspend()以及 resume()那样属于 Thread 的一部分。尽管这表面看有点儿奇怪——居然让专门进行线程处理
的东西成为通用基础类的一部分——但仔细想想又会释然,因为它们操纵的对象锁也属于每个对象的一部
分。因此,我们可将一个 wait()置入任何同步方法内部,无论在那个类里是否准备进行涉及线程的处理。事
实上,我们能调用 wait()的唯一地方是在一个同步的方法或代码块内部。若在一个不同步的方法内调用
wait()或者 notify(),尽管程序仍然会编译,但在运行它的时候,就会得到一个
IllegalMonitorStateException(非法监视器状态违例),而且会出现多少有点莫名其妙的一条消息:
“current thread not owner”(当前线程不是所有人”。注意 sleep(),suspend()以及resume()都能在不
同步的方法内调用,因为它们不需要对锁定进行操作。
只能为自己的锁定调用 wait()和 notify()。同样地,仍然可以编译那些试图使用错误锁定的代码,但和往常
一样会产生同样的 IllegalMonitorStateException 违例。我们没办法用其他人的对象锁来愚弄系统,但可要
求另一个对象执行相应的操作,对它自己的锁进行操作。所以一种做法是创建一个同步方法,令其为自己的
对象调用 notify()。

--------

### 死锁
由于线程可能进入堵塞状态,而且由于对象可能拥有“同步”方法——除非同步锁定被解除,否则线程不能
访问那个对象——所以 ***一个线程完全可能等候另一个对象,而另一个对象又在等候下一个对象*** ,以此类推。
这个“等候”链最可怕的情形就是进入封闭状态—— ***最后那个对象等候的是第一个对象*** !此时,所有线程都
会陷入无休止的相互等待状态,大家都动弹不得。我们将这种情况称为“死锁”。尽管这种情况并非经常出
现,但一旦碰到,程序的调试将变得异常艰难。
就语言本身来说,尚未直接提供防止死锁的帮助措施,需要我们通过谨慎的设计来避免。如果有谁需要调试
一个死锁的程序,他是没有任何窍门可用的。

--------

### 总结  
何时使用多线程技术,以及何时避免用它,这是我们需要掌握的重要课题。骼它的主要目的是对大量任务进
行有序的管理。通过多个任务的混合使用,可以更有效地利用计算机资源,或者对用户来说显得更方便。资
源均衡的经典问题是在 IO 等候期间如何利用 CPU。至于用户方面的方便性,最经典的问题就是如何在一个长
时间的下载过程中监视并灵敏地反应一个“停止”(stop )按钮的按下。

多线程的主要缺点包括:
1. 等候使用共享资源时造成程序的运行速度变慢。
2. 对线程进行管理要求的额外 CPU 开销。
3. 复杂程度无意义的加大,比如用独立的线程来更新数组内每个元素的愚蠢主意。
4. 漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。

线程另一个优点是它们用“轻度”执行切换(100 条指令的顺序)取代了“重度”进程场景切换(1000 条指
令)。由于一个进程内的所有线程共享相同的内存空间,所以“轻度”场景切换只改变程序的执行和本地变
量。而在“重度”场景切换时,一个进程的改变要求必须完整地交换内存空间。
线程处理看来好象进入了一个全新的领域,似乎要求我们学习一种全新的程序设计语言——或者至少学习一
系列新的语言概念。由于大多数微机操作系统都提供了对线程的支持,所以程序设计语言或者库里也出现了
对线程的扩展。

不管在什么情况下,涉及线程的程序设计:
1. 刚开始会让人摸不着头脑,要求改换我们传统的编程思路;
2. 其他语言对线程的支持看来是类似的。所以一旦掌握了线程的概念,在其他环境也不会有太大的困难。

尽管对线程的支持使 Java 语言的复杂程度多少有些增加,但请不要责怪 Java。毕竟,利用线程可以做许多
有益的事情。
多个线程可能共享同一个资源(比如一个对象里的内存),这是运用线程时面临的最大的一个麻烦。必须保
证多个线程不会同时试图读取和修改那个资源。这要求技巧性地运用 synchronized(同步)关键字。它是一
个有用的工具,但必须真正掌握它,因为假若操作不当,极易出现死锁。
除此以外,运用线程时还要注意一个非常特殊的问题。由于根据 Java 的设计,它允许我们根据需要创建任意
数量的线程——至少理论上如此(例如,假设为一项工程方面的有限元素分析创建数以百万的线程,这对
Java 来说并非实际)。然而,我们一般都要控制自己创建的线程数量的上限。因为在某些情况下,大量线程
会将场面变得一团糟,所以工作都会几乎陷于停顿。临界点并不象对象那样可以达到几千个,而是在 100 以
下。一般情况下,我们只创建少数几个关键线程,用它们解决某个特定的问题。这时数量的限制问题不大。
但在较常规的一些设计中,这一限制确实会使我们感到束手束脚。
大家要注意线程处理中一个不是十分直观的问题。由于采用了线程“调度”机制,所以通过在 run()的主循
环中插入对 sleep()的调用,一般都可以使自己的程序运行得更快一些。这使它对编程技巧的要求非常高,
特别是在更长的延迟似乎反而能提高性能的时候。当然,之所以会出现这种情况,是由于在正在运行的线程
准备进入“休眠”状态之前,较短的延迟可能造成“sleep()结束”调度机制的中断。这便强迫调度机制将其
中止,并于稍后重新启动,以便它能做完自己的事情,再进入休眠状态。必须多想一想,才能意识到事情真
正的麻烦程度。
